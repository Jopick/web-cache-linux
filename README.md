Документация

Обзор

Фреймворк предназначен для автоматизированного сбора и анализа цифровых артефактов из браузеров на базе Chromium в Linux-системах. Система модульная и позволяет парсить различные типы данных: cookies, историю посещений, закладки, расширения и историю загрузок.

**Архитектура системы**

**Основные компоненты:**

project/
    __init__.py
    Run.py                    # Точка входа
    Interfaces/               # Интерфейсы
        __init__.py
        Main.py              # Главный интерфейс
        LogInterface.py      # Логирование
        SettingsInterface.py # Настройки
        OutputInterface.py   # Вывод данных
        Solver.py           # Загрузчик модулей
    Common/                  # Общие утилиты
        __init__.py
        Codes.py            # Коды ошибок
        Routines.py         # Вспомогательные функции
        SACPStructure.py    # Структуры данных
    Modules/                # Модули парсинга
        ChromiumCookies/
        ChromiumHistory/
        ChromiumBookmarks/
        ChromiumExtensions/
        ChromiumDownloads/

**Пошаговая инструкция по запуску**

Шаг 1: Установка зависимостей

Установите необходимые Python-пакеты
pip install regipy sqlite3

Или через requirements.txt
pip install -r requirements.txt

Шаг 2: Подготовка структуры каталогов

Создайте следующую структуру:
LabFramework/
    Cases/           # Автоматически создается
    Temp/           # Автоматически создается
    Logs/           # Автоматически создается
    Modules/        # Папка для модулей
    Source/         # Папка с исходными данными
    Settings.json   # Файл настроек

Шаг 3: Настройка файла Settings.json

{
    "CaseFolder": "Cases",
    "TemporaryFilesFolder": "Temp"
}

Шаг 4: Добавление модулей парсинга

Скопируйте модули в папку Modules/. Каждый модуль должен содержать:
- __init__.py (пустой файл)
- Parser.py (класс Parser с методами __init__ и Start)

Шаг 5: Запуск приложения

Способ 1: Базовый запуск
python Run.py --source_folder ./Source --output_name results.sqlite

Способ 2: Анализ конкретного браузера
python Run.py --source_folder ~/.config/google-chrome --output_name chrome_analysis.sqlite

Способ 3: Помощь и параметры
python Run.py --help

Шаг 6: Проверка результатов

После выполнения программа создаст:
1. Лог-файл: Logs/[дата_время].log
2. Результаты: Cases/[дата_время]/[модуль]_results.sqlite
3. Временные файлы: Temp/ (автоматически очищаются)

**Поддерживаемые модули**

1. ChromiumCookies
Назначение: Парсинг cookies браузеров Chromium
Извлекаемые данные:
- Домены и имена cookies
- Значения (с поддержкой шифрования)
- Сроки действия
- Флаги безопасности (Secure, HttpOnly)
- Политики SameSite

2. ChromiumHistory
Назначение: Анализ истории посещений
Извлекаемые данные:
- URL посещенных страниц
- Заголовки страниц
- Количество посещений
- Время последнего посещения

3. ChromiumBookmarks
Назначение: Парсинг закладок
Извлекаемые данные:
- Названия закладок
- URL адреса
- Папки закладок
- Даты создания и изменения

4. ChromiumExtensions
Назначение: Анализ установленных расширений
Извлекаемые данные:
- Названия расширений
- ID и версии
- Описания и авторы
- Права доступа

5. ChromiumDownloads
Назначение: История загрузок
Извлекаемые данные:
- Пути к скачанным файлам
- URL источников
- Размеры файлов
- Статусы загрузок
- Уровни опасности

**Формат выходных данных**

Все модули сохраняют данные в SQLite базы данных со следующей структурой:

Таблицы в БД:
1. Data - основные данные модуля
2. Headers - описание полей (название, ширина, тип данных)
3. Info - метаинформация о модуле

Пример структуры Data для модуля Cookies:
CREATE TABLE Data (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    UserName TEXT,
    Browser TEXT,
    Host TEXT,
    CookieName TEXT,
    CookieValue TEXT,
    -- ... другие поля
);

**Принцип работы**

Фаза 1: Инициализация
1. Чтение настроек из Settings.json
2. Создание логгера и структуры каталогов
3. Парсинг аргументов командной строки

Фаза 2: Поиск данных
1. Сканирование системных каталогов на наличие браузеров
2. Проверка существования файлов данных (Cookies, History, Bookmarks и т.д.)
3. Создание временных копий для избежания блокировки

Фаза 3: Обработка данных
1. Динамическая загрузка модулей из папки Modules/
2. Выполнение логики парсинга каждого модуля
3. Конвертация временных меток Chromium в читаемый формат
4. Обработка шифрованных данных (если возможно)

Фаза 4: Сохранение результатов
1. Создание SQLite баз данных
2. Запись данных и метаинформации
3. Создание индексов для оптимизации поиска
4. Очистка временных файлов

**Особенности реализации**

Временные метки
Фреймворк использует класс TimeConverter для конвертации:
- Chromium времени (микросекунды с 1601-01-01) → читаемая дата
- FILETIME (Windows) → datetime
- Unix времени → datetime

Обработка реестра Windows
Классы RegistryFileHandler и _AbstractRegistryFileHandler предоставляют абстракцию для работы с файлами реестра, хотя в Linux-версии они используются ограниченно.

Безопасность данных
- Создание временных копий файлов БД для избежания блокировки
- Обработка исключений при доступе к файлам
- Корректное закрытие соединений с БД

**Расширение функциональности**

Создание нового модуля:

1. Создайте папку модуля в Modules/
2. Создайте файл Parser.py с шаблоном:

Описание модуля

class Parser():
    def __init__(self, parameters: dict):
        self.__parameters = parameters
        
    async def Start(self) -> dict:
        # Логика парсинга
        output_writer = self.__parameters.get('OUTPUTWRITER')
        
        # Настройка полей вывода
        record_fields = {'Field1': 'TEXT', 'Field2': 'INTEGER'}
        fields_description = {'Field1': ('Название', 100, 'string', 'Описание')}
        
        output_writer.SetFields(fields_description, record_fields)
        output_writer.CreateDatabaseTables()
        
        # Ваша логика парсинга
        
        return {self.__parameters.get('MODULENAME'): output_writer.GetDBName()}

**Коды ошибок**

class ExitCode(IntEnum):
    Ok = 0                    # Успешное завершение
    AsyncStartError = 1       # Ошибка асинхронного запуска
    ControlParametersError = 2 # Ошибка параметров управления
    InputParametersError = 3   # Ошибка входных параметров

**Ограничения и требования**

Требования к системе:
- Python 3.7+
- Linux ОС (тестировано на Ubuntu/Debian)
- Доступ к домашнему каталогу пользователя

Ограничения:
1. Шифрование cookies: Для дешифровки современных Chrome cookies требуется ключ из файла Local State
2. Браузеры: Поддерживаются только браузеры на базе Chromium
3. Версии: Могут быть различия в структуре данных между версиями браузеров

**Устранение неполадок**

Проблема: "Модуль не найден"
Решение: Убедитесь, что модуль находится в папке Modules/ и содержит файл Parser.py

Проблема: "Нет доступа к файлам браузера"
Решение: Запустите с правами нужного пользователя или скопируйте файлы в папку Source/

Проблема: "Ошибка формата времени"
Решение: Проверьте версию браузера - фреймворк поддерживает современный формат Chromium

**Краткая шпаргалка по командам**

Создать структуру проекта
mkdir -p {Cases,Temp,Logs,Modules,Source}

Базовый запуск
python Run.py --source_folder ./Source --output_name forensics.sqlite

Анализ Chrome с конкретным именем файла
python Run.py --source_folder ~/.config/google-chrome --output_name chrome_data.sqlite

Помощь
python Run.py --help
